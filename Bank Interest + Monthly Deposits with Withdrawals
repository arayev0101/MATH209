# Bank Interest Calculator, user input visualization. Amount (A), rate (r), time (t) (years), frequency (n) of compounding per year.
# A = P(1 + r/n)**(nt)

import numpy as np
import matplotlib.pyplot as plt

# Function to get a positive number from user with error handling
def get_positive_number(prompt, max_errors=2):
    error_count = 0
    while error_count < max_errors:
        try:
            value = float(input(prompt))
            if value <= 0:
                print("Error: Please enter a positive number (> 0).")
                error_count += 1
            else:
                return value
        except ValueError:
            print("Error: Please enter a valid number.")
            error_count += 1
    
    # if user made 2 errors, ask for confirmation
    print(f"You've made {max_errors} invalid attempts. Using your last input anyway...")
    try:
        value = float(input(prompt))
        return abs(value) if value != 0 else 1  # using absolute value or default to 1
    except ValueError:
        print("Using default value: 1")
        return 1

# function to get positive integer with error handling
def get_positive_integer(prompt, max_errors=2):
    error_count = 0
    while error_count < max_errors:
        try:
            value = int(input(prompt))
            if value <= 0:
                print("Error: Please enter a positive integer (> 0).")
                error_count += 1
            else:
                return value
        except ValueError:
            print("Error: Please enter a valid integer.")
            error_count += 1
    
    # in case if user made 2 errors + asking for confirmation
    print(f"You've made {max_errors} invalid attempts. Using your last input anyway...")
    try:
        value = int(input(prompt))
        return abs(value) if value != 0 else 1  # using absolute value or default to 1
    except ValueError:
        print("Using default value: 1")
        return 1

# function to get a non-negative number (inflation can be 0)
def get_non_negative_number(prompt, max_errors=2):
    error_count = 0
    while error_count < max_errors:
        try:
            value = float(input(prompt))
            if value < 0:
                print("Error: Please enter a non-negative number (>= 0).")
                error_count += 1
            else:
                return value
        except ValueError:
            print("Error: Please enter a valid number.")
            error_count += 1
    
    # case if user made 2 errors + asking for confirmation
    print(f"You've made {max_errors} invalid attempts. Using your last input anyway...")
    try:
        value = float(input(prompt))
        return abs(value)  # Use absolute value
    except ValueError:
        print("Using default value: 0")
        return 0

print("This is a Bank Interest Calculator.")
P = get_positive_number("Enter the principal amount (initial investment): $")
r = get_non_negative_number("Enter the annual interest rate (as a decimal, e.g., 0.05 for 5%): ")
t = get_positive_number("Enter the time the money is invested for (in years): ")
# keep user's chosen n for single-case result
n_user = get_positive_integer("Enter the number of times that interest is compounded per year (for single-case result): ")

# === NEW: monthly deposits and withdrawals ===
monthly_deposit = get_non_negative_number(
    "Enter the monthly deposit amount (0 for none): $"
)
monthly_withdrawal = get_non_negative_number(
    "Enter the monthly withdrawal amount (0 for none): $"
)
net_monthly_cashflow = monthly_deposit - monthly_withdrawal

# Compute final amount for the user's chosen frequency using a numerically-stable form
A_user = P * np.exp(n_user * t * np.log1p(r / n_user))
print(f"Amount after {t} years with n={n_user} compounding per year (no monthly cashflows): ${A_user:,.2f}")


# time axis (in years)
x = np.linspace(0, t, 500)

plt.figure(figsize=(9, 6))

# ask user for expected inflation to show real money
inflation = get_non_negative_number("Enter expected annual inflation rate (as a decimal, e.g., 0.02 for 2%): ")

# === NEW: simulate user's plan with monthly deposits/withdrawals ===
if net_monthly_cashflow != 0:
    # total number of months (assuming t in years; if t is not an integer, this is rounded)
    total_months = int(round(t * 12))
    if total_months > 0:
        # Effective annual growth factor for user's chosen compounding frequency
        # This respects their choice of n_user.
        eff_annual_factor = (1 + r / n_user) ** n_user if r > 0 else 1.0
        # Equivalent monthly factor
        monthly_factor = eff_annual_factor ** (1.0 / 12.0)

        balance = P
        balances = [balance]

        for month in range(1, total_months + 1):
            # grow by monthly interest
            balance *= monthly_factor
            # apply net monthly cashflow (deposit - withdrawal) at end of month
            balance += net_monthly_cashflow
            balances.append(balance)

        balances = np.array(balances, dtype=float)
        x_months = np.linspace(0.0, t, total_months + 1)

        # nominal curve with monthly cashflows
        plt.plot(
            x_months,
            balances,
            label=f"Your plan with monthly net ${net_monthly_cashflow:,.2f}"
        )
        # --- NEW: Label the final point for "your plan" ---
        final_balance = balances[-1]
        plt.plot(t, final_balance, 'o', color='blue', markersize=5)
        plt.text(t, final_balance, f' ${final_balance:,.2f}', va='center', ha='left', fontsize=8)


        # inflation-adjusted curve for monthly cashflows
        denom = np.exp(x_months * np.log1p(inflation))
        real_balances = balances / denom
        plt.plot(
            x_months,
            real_balances,
            linestyle=':',
            linewidth=2,
            label="Your plan (real, with monthly cash flow)"
        )

        print(
            f"With monthly deposits=${monthly_deposit:,.2f} and "
            f"withdrawals=${monthly_withdrawal:,.2f}, "
            f"final nominal amount after {t} years = ${balances[-1]:,.2f}"
        )
        print(
            f"Inflation-adjusted (real) amount with monthly cash flow "
            f"after {t} years = ${real_balances[-1]:,.2f}"
        )
else:
    print("No monthly deposits/withdrawals specified (net monthly cashflow = 0).")


#Compounding
y_cont = P * np.exp(r * x)
y_cont_final = P * np.exp(r * t)
plt.plot(x, y_cont, '--', label='Continuous')
plt.plot(t, y_cont_final, 'o', markersize=4)
plt.text(t, y_cont_final, f' ${y_cont_final:,.2f}', va='bottom', ha='left', fontsize=8)
print(f"Continuous compounding: final amount after {t} years = ${y_cont_final:,.2f}")

#Plot Lines
y_user_nominal = P * (1 + r / n_user) ** (n_user * x)
real_user = y_user_nominal / np.exp(x * np.log1p(inflation))
real_user_final = (P * (1 + r / n_user) ** (n_user * t)) / np.exp(t * np.log1p(inflation))
plt.plot(x, real_user, color='black', linewidth=2, label=f'Real (inflation-adjusted), your n={n_user}')
plt.plot(t, real_user_final, 's', color='black', markersize=3)
plt.text(t, real_user_final, f' ${real_user_final:,.2f}', va='center', ha='left', fontsize=8)
print(f"Inflation-adjusted (real) amount after {t} years with n={n_user}: ${real_user_final:,.2f}")

#Plot
plt.title(f"Account growth of ${P:,.2f} at {r*100:.2f}% over {t} years")
plt.xlabel("How long the money is invested in years")
plt.ylabel("Money in US dollars")
plt.grid(True)
plt.legend()
plt.tight_layout()

# show the plot
plt.show()
